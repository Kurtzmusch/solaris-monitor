#!/usr/bin/python3.6
from playsound import playsound
import requests
import getpass
import json
import time
import os
import threading
import datetime
from datetime import timezone
from threading import Thread


apiURL = 'https://api.solaris.games'
loginURL = '/api/auth/login'
gameURL = '/api/game/'
activeGamesURL = '/api/game/list/active'
headers = {
        'Content-Type': 'application/json;charset=UTF-8',
        'Sec-Fetch-Mode': 'cors',
        'Origin': 'https://solaris.games'
}
games = []
mainLock = threading.Lock()
terminate = False
ownPlayerID = ''
idString = 'id   '
totalString = ' total'
newString = ' new'
tickDurationString = ' tick-duration'
nextTickString = ' next-tick'
partialLength = len(idString)+len(totalString)+len(newString)+len(tickDurationString)+len(nextTickString)

def main():
    
    cookie = getCookie()
    if cookie is  None:
        cookie = login()
        if cookie is None:
            print('failed to log in')
            return
    getActiveGames(cookie)
    getGalaxyes(cookie)
    updateAttacks()
    clearTerminal()
    drawMonitor()
    initUpdaterThread()
    while(True):
        getpass.getpass('')
        with mainLock:
            command = input('command: ')
            print('')
            processCommand(command)

def getCookie():
    cookie = None
    try:
        cookieFile = open('solaris-cookie.cookie', 'r')
        cookie = cookieFile.read()
        cookieFile.close()
    except IOError:
        print('no auth cookie found, login required')
        cookieFile.close()
    finally:
        return cookie

def login():
    email = input('email: ')
    password = getpass.getpass()
    payload = '{"email": "'+email+'", "password": "'+password+'"}'
    payload = payload.encode('utf-8')

    url = apiURL+loginURL
    response = requests.post(url, data=payload, headers=headers)
    responseCookies = response.cookies.get_dict()
    if( 'connect.sid' in responseCookies ):
        authCookie = responseCookies['connect.sid']
        cookieFile = open('solaris-cookie.cookie', 'w')
        cookieFile.write( authCookie )
        cookieFile.close()
        print('connected')
        return authCookie
    else:
        return None

def getActiveGames(authCookie):
    authHeaders = headers.copy()
    authHeaders['Cookie'] = 'connect.sid='+authCookie
    url = apiURL+activeGamesURL
    response = requests.get(url, headers=authHeaders)
    if response.status_code != 200:
        print('failed, try reseting the cookie')
        exit()
    responseOBJ = json.loads(response.text)
    for responseGame in responseOBJ:
        game = {}
        game['name'] = responseGame['settings']['general']['name']
        game['id'] = responseGame['_id']
        game['fetched-attacks'] = []
        game['total-attacks'] = []
        game['new-attacks'] = []
        games.append(game)

def getGalaxyes(authCookie):
    #TODO ignore games that didnt start yet
    for game in games:
        game['enemy-carriers'] = []
        game['owned-stars'] = []
        getGalaxy(game['id'], authCookie, game)

def getGalaxy(gameID, authCookie, game):
    authHeaders = headers.copy()
    authHeaders['Cookie'] = 'connect.sid='+authCookie
    url = apiURL+gameURL+gameID+'/galaxy'
    print(url)
    response = requests.get(url, headers=authHeaders)
    if response.status_code != 200:
        print('failed, try reseting the cookie')
        exit()
    responseOBJ = json.loads(response.text)
    found = False
    for player in responseOBJ['galaxy']['players']:
        if( 'userId' in player ):
            ownPlayerID = player['_id']
            print(player['alias'])
            break

    for carrier in responseOBJ['galaxy']['carriers']:
        if carrier['ownedByPlayerId'] != ownPlayerID:
            game['enemy-carriers'].append(carrier)

    for star in responseOBJ['galaxy']['stars']:
        if( star['ownedByPlayerId'] == ownPlayerID ):
            game['owned-stars'].append(star['_id'])

    game['tick-duration'] = responseOBJ['settings']['gameTime']['speed']
    if 'lastTickDate' in responseOBJ['state']:
        treatedDateString = responseOBJ['state']['lastTickDate']
        treatedDateString = treatedDateString[:-5]
        lastTickDate = datetime.datetime.strptime(treatedDateString, '%Y-%m-%dT%H:%M:%S')
        game['lastTickTimestamp'] = lastTickDate.timestamp()

def printGames():
    printGamesHeader()
    index = 0
    nowDate = datetime.datetime.utcnow().timestamp()
    for game in games:
        tickDuration = game['tick-duration']
        if 'lastTickTimestamp' in game:
            nextTick = tickDuration - int((nowDate-game['lastTickTimestamp'])/60.0)
            nextTick = str(nextTick)+'m'
        else:
            nextTick = 'paused'

        totalCount = len(game['total-attacks'])
        newCount = len(game['new-attacks'])
        print( 
                str(index).ljust(5,' ')+
                game['name'].ljust(80-partialLength,' ')
                +(str(tickDuration)+'m').rjust(len(tickDurationString),' ')
                +nextTick.rjust(len(nextTickString),' ')
                +(str(totalCount)).rjust(len(totalString), ' ')
                +(str(newCount)).rjust(len(newString), ' ')
        )
        index += 1

def printGamesHeader():
    rows, columns = os.popen('stty size', 'r').read().split()
    totalLength = 80
    nameString = 'name'.ljust(totalLength-partialLength, ' ')
    print(idString+nameString+tickDurationString+nextTickString+totalString+newString)

def printEmptyLines(lineCount):
    for i in range(0,lineCount):
        print()

def clearTerminal():
    rows, columns = os.popen('stty size', 'r').read().split()
    printEmptyLines(int(rows))

def drawMonitor():
    rows, columns = os.popen('stty size', 'r').read().split()
    lineCount = int(rows)-len(games)-3
    printGames()
    printEmptyLines(lineCount)

def processCommand(commandString):
    for commandName, commandFunction in commands.items():
        if(commandString == commandName):
            commandFunction()
            return
    drawMonitor()

def updateAttacks():
    computeAttacks()
    collectAttacks()
    cleanUpNewAttacks()

def computeAttacks():
    for game in games:
        for carrier in game['enemy-carriers']:
            if 'waypoints' in carrier:
                if len(carrier['waypoints'])>0:
                    for starID in game['owned-stars']:
                        if carrier['waypoints'][0]['destination'] == starID:
                            game['fetched-attacks'].append({'id': (carrier['_id']+starID)} )

def cleanUpNewAttacks():
    for game in games:
        cleanedNewAttacks = []
        for attack in game['new-attacks']:
            exists = False
            for totalAttack in game['total-attacks']:
                if attack['id'] == totalAttack['id']:
                    exists = True
                    break
            if exists:
                cleanedNewAttacks.append(totalAttack)
        game['new-attacks'] = cleanedNewAttacks

def collectAttacks():
    newAttacks = False
    for game in games:
        for fetchedAttack in game['fetched-attacks']:
            alreadyAware = False
            for attack in game['total-attacks']:
                if (attack['id'] == fetchedAttack['id']):
                    alreadyAware = True
                    break
            if not alreadyAware:
                game['new-attacks'].append(fetchedAttack)
                newAttacks = True
        game['total-attacks'] = game['fetched-attacks']
        game['fetched-attacks'] = []
    if newAttacks:
        playsound('./download.mp3')


def updateLoop():
    global terminate
    while(not terminate):
        time.sleep(1.0)
        #TODO check if any games need update, if so: get lock, updateAttacks(), redraw
        with mainLock:
            drawMonitor()

def initUpdaterThread():
    updaterThread = Thread(target=updateLoop)
    updaterThread.start()

def quit():
    global terminate
    terminate = True
    exit()

commands = {
        'quit': quit,
        'exit': quit
}

main()
